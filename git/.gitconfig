[user]
	email = will@developerfy.com
	name = William Blackie

[init]
	defaultBranch = main

[push]
	autoSetupRemote = true
	default = current

[pull]
	rebase = false

[fetch]
	prune = true

[include]
	path = ~/.config/delta/catppuccin.gitconfig

[core]
	editor = nvim
	autocrlf = input
	excludesfile = ~/.gitignore_global
	ignorecase = true
	pager = delta

[alias]
	# Short commands
	st = status
	co = checkout
	br = branch
	cm = commit
	lg = log --oneline --graph --decorate --all
	
	# Useful aliases
	unstage = reset HEAD --
	last = log -1 HEAD
	visual = !gitk
	
	# Show files ignored by git
	ignored = ls-files --others --ignored --exclude-standard
	
	# Pretty log
	hist = log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short
	
	# Show diff of last commit
	dlc = diff --cached HEAD^
	
	# Undo last commit
	undo = reset --soft HEAD^
	wt-list = worktree list
	wt-new = "!f(){ raw=\"$1\"; base=\"${2:-origin/main}\"; [ -z \"$raw\" ] && { echo \"usage: git wt new <branch|slug> [base]\"; return 1; }; git fetch origin --prune || return 1; b=\"$raw\"; if ! git show-ref --verify --quiet \"refs/heads/$b\" && ! git show-ref --verify --quiet \"refs/remotes/origin/$b\"; then case \"$raw\" in williamblackie/*|main|master|develop|dev|release/*|hotfix/*) b=\"$raw\" ;; *) b=\"williamblackie/$raw\" ;; esac; fi; common=$(cd \"$(git rev-parse --git-common-dir)\" && pwd); if [ \"$(basename \"$common\")\" = \".git\" ]; then repo_root=$(dirname \"$common\"); repo=$(basename \"$repo_root\"); parent=$(dirname \"$repo_root\"); else repo_dir=\"$common\"; repo=$(basename \"$repo_dir\" .git); parent=$(dirname \"$repo_dir\"); fi; slug=$(printf \"%s\" \"${b#williamblackie/}\" | tr '/' '-'); wt_root=\"$parent/wt\"; dir=\"$wt_root/$repo-$slug\"; mkdir -p \"$wt_root\" || return 1; [ -e \"$dir\" ] && { echo \"worktree path exists: $dir\"; return 1; }; if git show-ref --verify --quiet \"refs/heads/$b\"; then p=$(git worktree list --porcelain | awk -v want=\"refs/heads/$b\" '$1==\"worktree\"{w=$2} $1==\"branch\" && $2==want {print w; exit}'); [ -n \"$p\" ] && { echo \"branch already checked out: $p\"; return 1; }; git worktree add \"$dir\" \"$b\" || return 1; echo \"attached: $b -> $dir\"; elif git show-ref --verify --quiet \"refs/remotes/origin/$b\"; then git worktree add --track -b \"$b\" \"$dir\" \"origin/$b\" || return 1; echo \"tracked: origin/$b -> $dir\"; else git worktree add -b \"$b\" \"$dir\" \"$base\" || return 1; echo \"created: $b from $base -> $dir\"; fi; }; f"
	wt-sync = "!f(){ [ \"$(git rev-parse --is-bare-repository)\" = true ] && { echo \"run in a worktree\"; return 1; }; git diff --quiet || { echo \"unstaged changes\"; return 1; }; git diff --cached --quiet || { echo \"staged changes\"; return 1; }; git fetch origin --prune || return 1; b=$(git rev-parse --abbrev-ref HEAD); [ \"$b\" = HEAD ] && { echo \"detached HEAD\"; return 1; }; if [ \"$b\" = main ]; then git pull --ff-only origin main; else git rebase origin/main; fi; }; f"
	wt-publish = "!f(){ [ \"$(git rev-parse --is-bare-repository)\" = true ] && { echo \"run in a worktree\"; return 1; }; b=$(git rev-parse --abbrev-ref HEAD); [ \"$b\" = HEAD ] && { echo \"detached HEAD\"; return 1; }; git push -u origin \"$b\"; }; f"
	wt-done = "!f(){ b=\"$1\"; force=\"$2\"; [ -z \"$b\" ] && { echo \"usage: git wt done <branch|slug> [--force]\"; return 1; }; case \"$b\" in main|master) echo \"refusing to remove $b\"; return 1 ;; williamblackie/*) ;; *) b=\"williamblackie/$b\" ;; esac; if [ \"$(git rev-parse --is-bare-repository)\" = false ]; then cur=$(git rev-parse --abbrev-ref HEAD); [ \"$cur\" = \"$b\" ] && { echo \"checkout another worktree first\"; return 1; }; fi; p=$(git worktree list --porcelain | awk -v want=\"refs/heads/$b\" '$1==\"worktree\"{w=$2} $1==\"branch\" && $2==want {print w; exit}'); if [ -n \"$p\" ]; then if [ \"$force\" = \"--force\" ]; then git worktree remove --force \"$p\" || return 1; else git worktree remove \"$p\" || return 1; fi; fi; if [ \"$force\" = \"--force\" ]; then git branch -D \"$b\" || return 1; else git branch -d \"$b\" || return 1; fi; git worktree prune; }; f"
	wt-prune = !git worktree prune && git worktree list
	wt = "!f(){ c=\"$1\"; shift || true; case \"$c\" in new|co|checkout|open) git wt-new \"$@\" ;; sync) git wt-sync ;; publish|pr) git wt-publish ;; done) git wt-done \"$@\" ;; list|ls) git wt-list ;; prune) git wt-prune ;; *) echo \"usage: git wt {new|checkout|sync|publish|done|list|prune}\"; return 1 ;; esac; }; f"

[color]
	ui = auto

[diff]
	tool = vimdiff

[merge]
	tool = vimdiff

[credential]
	helper = 
	helper = manager
	helper = 
	helper = /usr/local/share/gcm-core/git-credential-manager

[interactive]
	diffFilter = delta --color-only

[delta]
	features = catppuccin-mocha
	navigate = true
	line-numbers = true
	hyperlinks = true
[credential "https://dev.azure.com"]
	useHttpPath = true
